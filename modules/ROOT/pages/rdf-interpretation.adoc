= Interpretation as RDF
:prevent-blank-line:
include::../partials/_header.adoc[]

== Export vs Interpretation
[NOTE]
--
The JSON document can be exported as RDF. This resembles simply mapping the JSON tree document to a corresponding tree (RDF graph) of RDF resources. However, to actually export the knowledge _encoded_ in a {cj} graph, is often more interesting. This specification does not define an RDF Export, just an RDF Interpretation.
--

== Namespace Map (`@context`)
The document-level `@context` is used to expand prefixed IDs into full URIs for RDF export.
See xref:spec-cj.adoc#context[Context (Namespace Map)] for details on how IDs are expanded.

If no `@context` is provided, a default `@vocab` may be supplied at export time by the environment as a parameter. If no `@vocab` is given by any means, it defaults to the local file path using the `file://` scheme, with URL-encoding, where required.

== Node URI
Each node `id` is expanded to a URI using the `@context` namespace map (see xref:spec-cj.adoc#context[ID Expansion]).
Similarly, each edge `id` is expanded to a URI.
If the resulting URI would be syntactically invalid (e.g. because the `id` contains characters not allowed in a URI), the invalid characters must be https://www.rfc-editor.org/rfc/rfc3986#section-2.1[percent-encoded].
Ports are ignored in RDF.

[#edge-to-rdf]
== Edge Types
The type of an edge can be stated at the edge level and/or at the endpoint level. For bi-edges the edge level works fine and has a clear interpretation, even as RDF. However, an n-ary edge cannot always be interpreted as RDF.
I.e., the hyper-edge itself is not mapped to triples, but the induced bi-edges are.

The edge `type` (__edge__.`type`) defines a type for each endpoint. It can be overwritten per endpoint (__endpoint__.`type`).
At export time, the `type` string (a node `id`) is expanded to a URI using the `@context` namespace map.

.Algorithm for Interpreting a (Hyper-)Edge as RDF Triples
- Compute the effective endpoint type:
** Start with the edge-level `type`.
** If the endpoint defines its own `type`, it overrides the edge-level type.
** Expand the effective type to a URI using `@context`.

- Process each pair of endpoints (A,B):
** Sort pair into first and second.
** For each type URI in the pair, generate an RDF triple from `in` to `out`:
+
If __in__ has a type URI, generate +
(in.node, in.typeUri, out.node).
+
If __out__ has a type URI, generate +
(in.node, out.typeUri, out.node).

.Mapping of Endpoint Pair
[cols="^1m,^1m,1,1"]
|===
2+h| Input  2+h| Resulting RDF Order
h| A h| B h| Subject h| Object

|    in |    in 2+e| Skip
|    in |   out    | A | B
|    in | undir    | A | B
|   out |    in    | B | A
|   out |   out 2+e| Skip
|   out | undir    | B | A
| undir |    in    | B | A
| undir |   out    | A | B
| undir | undir    | A | B
|===


== Examples

=== Simple Bi-Edge
Given document `@context`: `{ "ex": "https://example.org/" }`

.Example: Bi-Edge with One Type in {cj}
[source,json]
----
{
  "endpoints": [
    { "node": "n12",
      "direction": "in"  },
    { "node": "n17",
      "direction": "out",
      "type": "ex:worksAt" }
  ]
}
----
interpretation as RDF (Turtle Syntax)
[source,turtle]
----
@prefix ex: <https://example.org/> .
ex:n12 ex:worksAt ex:n17 .
----

NOTE: The following {ecj} example uses `source`/`target` and `endpoints`, which is allowed but uncommon. The endpoints stated using `source`/`target` have no endpoint types defined.

=== Hyper-Edge
Given document `@context`: `{ "ex": "https://example.org/" }`

.Example: Hyper-Edge
[source,json]
----
{
  "id": "sale123",
  "source": ["n12","n3","n123"],
  "target": ["n17","n100"],
  "endpoints": [
    { "node": "n100", "direction": "in",
      "type": "ex:sells" },
    { "node": "n12",  "direction": "in",
      "type": "ex:buys" },
    { "node": "n3",   "direction": "undir"  },
    { "node": "item-1",  "direction": "out" }
  ]
}
----
interpretation as RDF (Turtle Syntax)
[source,turtle]
----
@prefix ex: <https://example.org/> .
ex:n100 ex:sells ex:item-1 .
ex:n12  ex:buys  ex:item-1 .
----
